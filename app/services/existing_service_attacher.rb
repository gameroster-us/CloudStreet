class ExistingServiceAttacher < CloudStreetService
	EXISTING_SERVICES = %w( Services::Network::Subnet::AWS )
	def self.add_existing_services(user, organisation, environment, params, &block)
		klass = ActionController::Base.helpers.sanitize(params[:type])
    service_type = klass.safe_constantize
		added_services = []
		if EXISTING_SERVICES.include?(service_type)
			arr = service_type.split("::")
			service_class_name = "#{arr[2].pluralize}::#{arr[3]}"
			params[:service_ids].each do |service_id|
				service_record = service_class_name.constantize.find(service_id)
				ActiveRecord::Base.transaction do
					env_az_service = environment.services.availability_zones.where("data ->> 'code' = ?", service_record.availability_zone)

					Services::Network::AvailabilityZone.create_az_service(service_record, organisation, environment, user) if env_az_service.blank? && service_type.eql?('Services::Network::Subnet::AWS')
					new_service_object = service_type.constantize.create_service_object(service_record, environment)
					unless new_service_object.blank?
						environment.services << new_service_object
						environment.updated_by = user.id
						environment.save!
						new_service_object.find_or_create_default_interface_connections
						new_service_object.user = user
						environment.services.vpcs.each do |vpc|
							Interface.find_or_create_interfaces(new_service_object,vpc)
						end

						environment.services.availability_zones.where("data ->> 'code' = ?", new_service_object.availability_zone).each do |az|
							Interface.find_or_create_interfaces(new_service_object,az)
						end
						new_service_object.set_additional_properties!

						if organisation.account.naming_convention_enabled? && service_record.state == 'pending'
							new_service_object.name = new_service_object.get_autogenerated_name(user, environment)
						end      			
						new_service_object.save!
						new_service_object.provision if (service_record.state == 'pending' || service_record.state == 'available') && !%w[pending stopped].include?(environment.state)
						added_services << new_service_object
						revision_data = environment.prepare_revision_data(event: 'added_to_environment', service: new_service_object.reload)   
						Events::Service::AddedToEnvironment.create(account: organisation.account, service: new_service_object.reload, environment: environment, user: user, revision_data: revision_data)
					end
				end
			end
      # bulk index into solr start-      
      SolrOperations::IndexObjectsIntoSolrWorker.perform_async("Service", added_services.map(&:id), "ExistingServiceAttacher.add_existing_services")
      # - bulk index into solr end
			::ImageUpdateWorker.perform_async(environment.id, user.id) if user && environment
			status Status, :success, added_services, &block
    		return added_services  
		else
			status Status, :error, "No service found with the type #{service_type}", &block
    		return added_services
		end 
	end
end
